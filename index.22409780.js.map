{"mappings":"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","sources":["node_modules/@swc/helpers/lib/_array_with_holes.js","node_modules/@swc/helpers/lib/_iterable_to_array.js","node_modules/@swc/helpers/lib/_non_iterable_rest.js","node_modules/@swc/helpers/lib/_unsupported_iterable_to_array.js","node_modules/@swc/helpers/lib/_array_like_to_array.js","node_modules/@swc/helpers/lib/_array_without_holes.js","node_modules/@swc/helpers/lib/_non_iterable_spread.js","node_modules/@swc/helpers/lib/_define_property.js","node_modules/@swc/helpers/lib/_sliced_to_array.js","node_modules/@swc/helpers/lib/_to_consumable_array.js","node_modules/@swc/helpers/lib/_type_of.js","node_modules/solid-js/dist/solid.js","node_modules/@swc/helpers/lib/_object_spread.js","node_modules/solid-js/web/dist/web.js","src/app/components/language.tsx","dist/dictionary.json","src/dictionary/unicode.ts","src/app/components/list.tsx","src/app/utilities/strings.ts","src/app/components/search.tsx","src/app/components/app.tsx","src/app/main.tsx"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayWithHoles;\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _iterableToArray;\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _nonIterableRest;\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _unsupportedIterableToArray;\nvar _arrayLikeToArray = _interopRequireDefault(require(\"./_array_like_to_array\"));\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return (0, _arrayLikeToArray).default(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0, _arrayLikeToArray).default(o, minLen);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayLikeToArray;\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _arrayWithoutHoles;\nvar _arrayLikeToArray = _interopRequireDefault(require(\"./_array_like_to_array\"));\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return (0, _arrayLikeToArray).default(arr);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _nonIterableSpread;\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _defineProperty;\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _slicedToArray;\nvar _arrayWithHoles = _interopRequireDefault(require(\"./_array_with_holes\"));\nvar _iterableToArray = _interopRequireDefault(require(\"./_iterable_to_array\"));\nvar _nonIterableRest = _interopRequireDefault(require(\"./_non_iterable_rest\"));\nvar _unsupportedIterableToArray = _interopRequireDefault(require(\"./_unsupported_iterable_to_array\"));\nfunction _slicedToArray(arr, i) {\n    return (0, _arrayWithHoles).default(arr) || (0, _iterableToArray).default(arr, i) || (0, _unsupportedIterableToArray).default(arr, i) || (0, _nonIterableRest).default();\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _toConsumableArray;\nvar _arrayWithoutHoles = _interopRequireDefault(require(\"./_array_without_holes\"));\nvar _iterableToArray = _interopRequireDefault(require(\"./_iterable_to_array\"));\nvar _nonIterableSpread = _interopRequireDefault(require(\"./_non_iterable_spread\"));\nvar _unsupportedIterableToArray = _interopRequireDefault(require(\"./_unsupported_iterable_to_array\"));\nfunction _toConsumableArray(arr) {\n    return (0, _arrayWithoutHoles).default(arr) || (0, _iterableToArray).default(arr) || (0, _unsupportedIterableToArray).default(arr) || (0, _nonIterableSpread).default();\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _typeof;\nfunction _typeof(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\n;\n","let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        root = fn.length === 0 && !false ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  };\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(() => fn(() => cleanNode(root)), true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE);\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) ;else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (false) ;\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) ;else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Updates = null;\n    if (!wait) Effects = null;\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    res = Transition.resolve;\n    Effects.forEach(e => {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    });\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      });\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || \"@@observable\";\n}\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = \"next\" in observer ? observer.next.bind(observer) : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n      };\n    },\n    [$$observable]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = untrack(() => Comp(props || {}));\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nconst NoErrors = {};\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn(NoErrors));\n}\nfunction ErrorBoundary(props) {\n  let err = NoErrors;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count) || NoErrors;\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if ((e = errored()) !== NoErrors) {\n      const f = props.fallback;\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(NoErrors))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = untrack(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered;\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = _objectSpread;\nvar _defineProperty = _interopRequireDefault(require(\"./_define_property\"));\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            (0, _defineProperty).default(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n","import { createMemo, createRoot, createRenderEffect, sharedConfig, enableHydration, createSignal, onCleanup, splitProps, untrack } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, mergeProps } from 'solid-js';\n\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = {\n  className: \"class\",\n  htmlFor: \"for\"\n};\nconst PropAliases = {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n};\nconst DelegatedEvents = new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = new Set([\n\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\",\n\"set\", \"stop\",\n\"svg\", \"switch\", \"symbol\", \"text\", \"textPath\",\n\"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = new Set([\"html\", \"base\", \"head\", \"link\", \"meta\", \"style\", \"title\", \"body\", \"address\", \"article\", \"aside\", \"footer\", \"header\", \"main\", \"nav\", \"section\", \"body\", \"blockquote\", \"dd\", \"div\", \"dl\", \"dt\", \"figcaption\", \"figure\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"a\", \"abbr\", \"b\", \"bdi\", \"bdo\", \"br\", \"cite\", \"code\", \"data\", \"dfn\", \"em\", \"i\", \"kbd\", \"mark\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"time\", \"u\", \"var\", \"wbr\", \"area\", \"audio\", \"img\", \"map\", \"track\", \"video\", \"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"portal\", \"source\", \"svg\", \"math\", \"canvas\", \"noscript\", \"script\", \"del\", \"ins\", \"caption\", \"col\", \"colgroup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"button\", \"datalist\", \"fieldset\", \"form\", \"input\", \"label\", \"legend\", \"meter\", \"optgroup\", \"option\", \"output\", \"progress\", \"select\", \"textarea\", \"details\", \"dialog\", \"menu\", \"summary\", \"details\", \"slot\", \"template\", \"acronym\", \"applet\", \"basefont\", \"bgsound\", \"big\", \"blink\", \"center\", \"content\", \"dir\", \"font\", \"frame\", \"frameset\", \"hgroup\", \"image\", \"keygen\", \"marquee\", \"menuitem\", \"nobr\", \"noembed\", \"noframes\", \"plaintext\", \"rb\", \"rtc\", \"shadow\", \"spacer\", \"strike\", \"tt\", \"xmp\", \"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"image\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"portal\", \"pre\", \"progress\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"shadow\", \"slot\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"xmp\", \"input\"]);\n\nfunction memo(fn, equals) {\n  return createMemo(fn, undefined, !equals ? {\n    equals\n  } : undefined);\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n        while (i < bEnd) map.set(b[i], i++);\n      }\n      const index = map.get(a[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  });\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n    delete document[$$EVENTS];\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");else node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    node.addEventListener(name, e => handler[0](handler[1], e));\n  } else node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n        prevKeys = Object.keys(prev);\n  let i, len;\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev = {}) {\n  const nodeStyle = node.style;\n  const prevString = typeof prev === \"string\";\n  if (value == null && prevString || typeof value === \"string\") return nodeStyle.cssText = value;\n  prevString && (nodeStyle.cssText = undefined, prev = {});\n  value || (value = {});\n  let v, s;\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n  for (s in value) {\n    v = value[s];\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, accessor, isSVG, skipChildren) {\n  if (typeof accessor === \"function\") {\n    createRenderEffect(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));\n  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);\n}\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n    enumerable: true\n  });\n  return props;\n}\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n  sharedConfig.gather = root => gatherHydratable(element, root);\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes]);\n  sharedConfig.context = null;\n  return dispose;\n}\nfunction getNextElement(template) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n  return el;\n}\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n  return [end, current];\n}\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n  if (prop === \"ref\") {\n    if (!skipRef) {\n      value(node);\n    }\n  } else if (prop.slice(0, 3) === \"on:\") {\n    node.addEventListener(prop.slice(3), value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    node.addEventListener(prop.slice(10), value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    addEventListener(node, name, value, delegate);\n    delegate && delegateEvents([name]);\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (prop === \"class\" || prop === \"className\") className(node, value);else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) {\n    sharedConfig.done = true;\n    document.querySelectorAll(\"[id^=pl-]\").forEach(elem => elem.remove());\n  }\n  while (node !== null) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler(data, e) : handler(e);\n      if (e.cancelBubble) return;\n    }\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\nfunction spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {\n  props || (props = {});\n  if (!skipChildren && \"children\" in props) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  props.ref && props.ref(node);\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n  while (typeof current === \"function\") current = current();\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\") v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    if (normalizeIncomingArray(array, value, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (Array.isArray(current)) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, unwrap) {\n  let dynamic = false;\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        t;\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item) || dynamic;\n    } else if ((t = typeof item) === \"string\") {\n      normalized.push(document.createTextNode(item));\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else normalized.push(document.createTextNode(item.toString()));\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n  return [node];\n}\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key)) sharedConfig.registry.set(key, node);\n  }\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nfunction Assets() {\n  return;\n}\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\nfunction ssr(template, ...nodes) {}\nfunction resolveSSRNode(node) {}\nfunction ssrClassList(value) {}\nfunction ssrStyle(value) {}\nfunction ssrSpread(accessor) {}\nfunction ssrBoolean(key, value) {}\nfunction ssrHydrationKey() {}\nfunction escape(html) {}\nfunction generateHydrationScript() {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      }\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  return createMemo(() => {\n    const component = p.component;\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, Assets, ChildProperties, DOMElements, DelegatedEvents, Dynamic, Assets as HydrationScript, NoHydration, Portal, PropAliases, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, className, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, innerHTML, insert, isServer, memo, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrBoolean, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle, style, template };\n","import { Component } from \"solid-js\";\nimport { Language } from \"../../schemas/languages\";\n\ninterface Props {\n  selected: Language;\n  setLanguage: (lang: Language) => void;\n}\n\nconst LanguageSelector: Component<Props> = (props) => {\n  return (\n    <select\n      onChange={(ev) =>\n        props.setLanguage((ev.target as HTMLSelectElement).value as Language)\n      }\n    >\n      <option value=\"sl\" selected>\n        sl\n      </option>\n    </select>\n  );\n};\n\nexport default LanguageSelector;\n","[\n  {\n    \"value\": \"acrobatics\",\n    \"normalized\": \"acrobatics\",\n    \"description\": \"Your Dexterity (Acrobatics) check covers your attempt to stay on your feet in a tricky situation, such as when you're trying to run across a sheet of ice, balance on a tightrope, or stay upright on a rocking ship's deck. The GM might also call for a Dexterity (Acrobatics) check to see if you can perform acrobatic stunts, including dives, rolls, somersaults, and flips.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"okretnost\",\n        \"alternatives\": [\n          \"gibčnost\",\n          \"prožnost\",\n          \"urnost\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"action\",\n    \"normalized\": \"action\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"dejanje\"\n      }\n    ]\n  },\n  {\n    \"value\": \"animal handling\",\n    \"normalized\": \"animal handling\",\n    \"description\": \"When there is any question whether you can calm down a domesticated animal, keep a mount from getting spooked, or intuit an animal’s intentions, the GM might call for a Wisdom (Animal Handling) check. You also make a Wisdom (Animal Handling) check to control your mount when you attempt a risky maneuver.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"rokovanje z živalmi\"\n      }\n    ]\n  },\n  {\n    \"value\": \"arcana\",\n    \"normalized\": \"arcana\",\n    \"description\": \"Your Intelligence (Arcana) check measures your ability to recall lore about spells, magic items, eldritch symbols, magical traditions, the planes of existence, and the inhabitants of those planes.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"arkana\"\n      }\n    ]\n  },\n  {\n    \"value\": \"armor\",\n    \"normalized\": \"armor\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"oklep\"\n      }\n    ]\n  },\n  {\n    \"value\": \"armor class\",\n    \"normalized\": \"armor class\",\n    \"description\": \"Your Armor Class (AC) represents how well your character avoids being wounded in battle. Things that contribute to your AC include the armor you wear, the shield you carry, and your Dexterity modifier. Not all characters wear armor or carry shields, however. Without armor or a shield, your character’s AC equals 10 + his or her Dexterity modifier. If your character wears armor, carries a shield, or both, calculate your AC using the rules in the Equipment section. Record your AC on your character sheet.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"red oklepa\"\n      }\n    ]\n  },\n  {\n    \"value\": \"athletics\",\n    \"normalized\": \"athletics\",\n    \"description\": \"Your Strength (Athletics) check covers difficult situations you encounter while climbing, jumping, or swimming.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"atletika\"\n      }\n    ]\n  },\n  {\n    \"value\": \"attack\",\n    \"normalized\": \"attack\",\n    \"description\": \"The most common action to take in combat is the Attack action, whether you are swinging a sword, firing an arrow from a bow, or brawling with your fists.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"napadati\"\n      }\n    ]\n  },\n  {\n    \"value\": \"blinded\",\n    \"normalized\": \"blinded\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"zaslepljen\",\n        \"alternatives\": [\n          \"slep\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"bonus\",\n    \"normalized\": \"bonus\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"dodatek\",\n        \"alternatives\": [\n          \"bonus\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"cast a spell\",\n    \"normalized\": \"cast a spell\",\n    \"description\": \"Spellcasters such as wizards and clerics, as well as many monsters, have access to spells and can use them to great effect in combat. Each spell has a casting time, which specifies whether the caster must use an action, a reaction, minutes, or even hours to cast the spell. Casting a spell is, therefore, not necessarily an action. Most spells do have a casting time of 1 action, so a spellcaster often uses his or her action in combat to cast such a spell.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"uporabiti urok\"\n      }\n    ]\n  },\n  {\n    \"value\": \"charisma\",\n    \"normalized\": \"charisma\",\n    \"description\": \"Charisma measures your ability to interact effectively with others. It includes such factors as confidence and eloquence, and it can represent a charming or commanding personality.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"karizma\"\n      }\n    ]\n  },\n  {\n    \"value\": \"charmed\",\n    \"normalized\": \"charmed\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"očaran\"\n      }\n    ]\n  },\n  {\n    \"value\": \"check\",\n    \"normalized\": \"check\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"poskus\"\n      }\n    ]\n  },\n  {\n    \"value\": \"combat\",\n    \"normalized\": \"combat\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"boj\",\n        \"alternatives\": [\n          \"spopad\",\n          \"obračun\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"condition\",\n    \"normalized\": \"condition\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"stanje\"\n      }\n    ]\n  },\n  {\n    \"value\": \"constitution\",\n    \"normalized\": \"constitution\",\n    \"description\": \"Constitution measures health, stamina, and vital force.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"fizično stanje\",\n        \"alternatives\": [\n          \"konstitucija\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"dash\",\n    \"normalized\": \"dash\",\n    \"description\": \"When you take the Dash action, you gain extra movement for the current turn. The increase equals your speed, after applying any modifiers. With a speed of 30 feet, for example, you can move up to 60 feet on your turn if you dash.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"šprintati\",\n        \"alternatives\": [\n          \"teči na vso moč\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"deafened\",\n    \"normalized\": \"deafened\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"oglušen\",\n        \"alternatives\": [\n          \"gluh\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"deception\",\n    \"normalized\": \"deception\",\n    \"description\": \"Your Charisma (Deception) check determines whether you can convincingly hide the truth, either verbally or through your actions. This deception can encompass everything from misleading others through ambiguity to telling outright lies. Typical situations include trying to fast-talk a guard, con a merchant, earn money through gambling, pass yourself off in a disguise, dull someone's suspicions with false assurances, or maintain a straight face while telling a blatant lie.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"pretveza\",\n        \"alternatives\": [\n          \"goljufanje\",\n          \"sleparija\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"dexterity\",\n    \"normalized\": \"dexterity\",\n    \"description\": \"Dexterity measures agility, reflexes, and balance.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"spretnost\"\n      }\n    ]\n  },\n  {\n    \"value\": \"dice\",\n    \"normalized\": \"dice\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"kocke\"\n      }\n    ]\n  },\n  {\n    \"value\": \"die\",\n    \"normalized\": \"die\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"kocka\"\n      }\n    ]\n  },\n  {\n    \"value\": \"disengage\",\n    \"normalized\": \"disengage\",\n    \"description\": \"If you take the Disengage action, your movement doesn't provoke opportunity attacks for the rest of the turn.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"odmikati\",\n        \"alternatives\": [\n          \"izmikati\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"dodge\",\n    \"normalized\": \"dodge\",\n    \"description\": \"When you take the Dodge action, you focus entirely on avoiding attacks. Until the start of your next turn, any attack roll made against you has disadvantage if you can see the attacker, and you make Dexterity saving throws with advantage. You lose this benefit if you are incapacitated or if your speed drops to 0.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"umikati\",\n        \"alternatives\": [\n          \"izogibati\",\n          \"ogniti\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"exhaustion\",\n    \"normalized\": \"exhaustion\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"izčrpanost\",\n        \"alternatives\": [\n          \"utrujenost\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"feat\",\n    \"normalized\": \"feat\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"podvig\"\n      }\n    ]\n  },\n  {\n    \"value\": \"frightened\",\n    \"normalized\": \"frightened\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"prestrašen\"\n      }\n    ]\n  },\n  {\n    \"value\": \"grapple\",\n    \"normalized\": \"grapple\",\n    \"description\": \"When you want to grab a creature or wrestle with it, you can use the Attack action to make a special melee attack, a grapple. If you're able to make multiple attacks with the Attack action, this attack replaces one of them.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"ujeti\",\n        \"alternatives\": [\n          \"uloviti\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"grappled\",\n    \"normalized\": \"grappled\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"ujet\"\n      }\n    ]\n  },\n  {\n    \"value\": \"help\",\n    \"normalized\": \"help\",\n    \"description\": \"You can lend your aid to another creature in the completion of a task. When you take the Help action, the creature you aid gains advantage on the next ability check it makes to perform the task you are helping with, provided that it makes the check before the start of your next turn.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"pomagati\"\n      }\n    ]\n  },\n  {\n    \"value\": \"hide\",\n    \"normalized\": \"hide\",\n    \"description\": \"When you take the Hide action, you make a Dexterity (Stealth) check in an attempt to hide, following the rules for hiding. If you succeed, you gain certain benefits, as described in the \\\"Unseen Attackers and Targets\\\" section later in this chapter.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"skriti se\"\n      }\n    ]\n  },\n  {\n    \"value\": \"history\",\n    \"normalized\": \"history\",\n    \"description\": \"Your Intelligence (History) check measures your ability to recall lore about historical events, legendary people, ancient kingdoms, past disputes, recent wars, and lost civilizations.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"zgodovina\",\n        \"alternatives\": [\n          \"preteklost\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"hit points\",\n    \"normalized\": \"hit points\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"točke odpornosti\",\n        \"alternatives\": [\n          \"točke zdravja\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"immunity\",\n    \"normalized\": \"immunity\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"neranljivost\",\n        \"alternatives\": [\n          \"nedotakljivost\",\n          \"imunost\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"improvise\",\n    \"normalized\": \"improvise\",\n    \"description\": \"Your character can do things not covered by the actions in this chapter, such as breaking down doors, intimidating enemies, sensing weaknesses in magical defenses, or calling for a parley with a foe. The only limits to the actions you can attempt are your imagination and your character's ability scores. See the descriptions of the ability scores in chapter 7 for inspiration as you improvise.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"improvizirati\",\n        \"alternatives\": [\n          \"prilagoditi\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"incapacitated\",\n    \"normalized\": \"incapacitated\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"onemogočen\",\n        \"alternatives\": [\n          \"onesposobljen\",\n          \"izključen\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"initiative\",\n    \"normalized\": \"initiative\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"pobuda\"\n      }\n    ]\n  },\n  {\n    \"value\": \"insight\",\n    \"normalized\": \"insight\",\n    \"description\": \"Your Wisdom (Insight) check decides whether you can determine the true intentions of a creature, such as when searching out a lie or predicting someone’s next move. Doing so involves gleaning clues from body language, speech habits, and changes in mannerisms.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"vpogled\",\n        \"alternatives\": [\n          \"uvid\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"inspiration\",\n    \"normalized\": \"inspiration\",\n    \"description\": \"Inspiration is a rule the game master can use to reward you for playing your character in a way that’s true to his or her personality traits, ideal, bond, and flaw. By using inspiration, you can draw on your personality trait of compassion for the downtrodden to give you an edge in negotiating with the Beggar Prince. Or inspiration can let you call on your bond to the defense of your home village to push past the effect of a spell that has been laid on you.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"navdih\",\n        \"alternatives\": [\n          \"inspiracija\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"intelligence\",\n    \"normalized\": \"intelligence\",\n    \"description\": \"Intelligence measures mental acuity, accuracy of recall, and the ability to reason.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"pamet\"\n      }\n    ]\n  },\n  {\n    \"value\": \"intimidation\",\n    \"normalized\": \"intimidation\",\n    \"description\": \"When you attempt to influence someone through overt threats, hostile actions, and physical violence, the GM might ask you to make a Charisma (Intimidation) check. Examples include trying to pry information out of a prisoner, convincing street thugs to back down from a confrontation, or using the edge of a broken bottle to convince a sneering vizier to reconsider a decision.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"ustrahovanje\",\n        \"alternatives\": [\n          \"zastraševanje\",\n          \"grozenje\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"inventory\",\n    \"normalized\": \"inventory\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"oprema\",\n        \"alternatives\": [\n          \"zaloga\",\n          \"inventar\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"investigation\",\n    \"normalized\": \"investigation\",\n    \"description\": \"When you look around for clues and make deductions based on those clues, you make an Intelligence (Investigation) check. You might deduce the location of a hidden object, discern from the appearance of a wound what kind of weapon dealt it, or determine the weakest point in a tunnel that could cause it to collapse. Poring through ancient scrolls in search of a hidden fragment of knowledge might also call for an Intelligence (Investigation) check.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"preiskovanje\",\n        \"alternatives\": [\n          \"raziskovanje\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"invisible\",\n    \"normalized\": \"invisible\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"neviden\"\n      }\n    ]\n  },\n  {\n    \"value\": \"language\",\n    \"normalized\": \"language\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"jezik\"\n      }\n    ]\n  },\n  {\n    \"value\": \"long rest\",\n    \"normalized\": \"long rest\",\n    \"description\": \"A long rest is a period of extended downtime, at least 8 hours long, during which a character sleeps for at least 6 hours and performs no more than 2 hours of light activity, such as reading, talking, eating, or standing watch.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"dolg počitek\",\n        \"alternatives\": [\n          \"dolg odmor\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"medicine\",\n    \"normalized\": \"medicine\",\n    \"description\": \"A Wisdom (Medicine) check lets you try to stabilize a dying companion or diagnose an illness.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"zdravljenje\"\n      }\n    ]\n  },\n  {\n    \"value\": \"nature\",\n    \"normalized\": \"nature\",\n    \"description\": \"Your Intelligence (Nature) check measures your ability to recall lore about terrain, plants and animals, the weather, and natural cycles.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"naravoslovje\",\n        \"alternatives\": [\n          \"prirodoslovje\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"paralyzed\",\n    \"normalized\": \"paralyzed\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"ohromljen\",\n        \"alternatives\": [\n          \"paraliziran\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"passive\",\n    \"normalized\": \"passive\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"nedejaven\",\n        \"alternatives\": [\n          \"pasiven\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"passive check\",\n    \"normalized\": \"passive check\",\n    \"description\": \"A passive check is a special kind of ability check that doesn't involve any die rolls. Such a check can represent the average result for a task done repeatedly, such as searching for secret doors over and over again, or can be used when the DM wants to secretly determine whether the characters succeed at something without rolling dice, such as noticing a hidden monster.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"nedejaven poskus\",\n        \"alternatives\": [\n          \"pasiven poskus\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"perception\",\n    \"normalized\": \"perception\",\n    \"description\": \"Your Wisdom (Perception) check lets you spot, hear, or otherwise detect the presence of something. It measures your general awareness of your surroundings and the keenness of your senses. For example, you might try to hear a conversation through a closed door, eavesdrop under an open window, or hear monsters moving stealthily in the forest. Or you might try to spot things that are obscured or easy to miss, whether they are orcs lying in ambush on a road, thugs hiding in the shadows of an alley, or candlelight under a closed secret door.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"zaznavanje\",\n        \"alternatives\": [\n          \"razumevanje\",\n          \"doumevanje\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"performance\",\n    \"normalized\": \"performance\",\n    \"description\": \"Your Charisma (Performance) check determines how well you can delight an audience with music, dance, acting, storytelling, or some other form of entertainment.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"nastopanje\"\n      }\n    ]\n  },\n  {\n    \"value\": \"persuasion\",\n    \"normalized\": \"persuasion\",\n    \"description\": \"When you attempt to influence someone or a group of people with tact, social graces, or good nature, the GM might ask you to make a Charisma (Persuasion) check. Typically, you use persuasion when acting in good faith, to foster friendships, make cordial requests, or exhibit proper etiquette. Examples of persuading others include convincing a chamberlain to let your party see the king, negotiating peace between warring tribes, or inspiring a crowd of townsfolk.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"prepričevanje\",\n        \"alternatives\": [\n          \"prigovarjanje\",\n          \"nagovarjanje\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"petrified\",\n    \"normalized\": \"petrified\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"okamenjen\"\n      }\n    ]\n  },\n  {\n    \"value\": \"poisoned\",\n    \"normalized\": \"poisoned\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"zastrupljen\"\n      }\n    ]\n  },\n  {\n    \"value\": \"proficiency\",\n    \"normalized\": \"proficiency\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"izurjenost\",\n        \"alternatives\": [\n          \"strokovnost\",\n          \"zanesljivost\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"proficiency bonus\",\n    \"normalized\": \"proficiency bonus\",\n    \"description\": \"Characters have a proficiency bonus determined by level, as detailed in chapter 1. Monsters also have this bonus, which is incorporated in their stat blocks. The bonus is used in the rules on ability checks, saving throws, and attack rolls.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"dodatek za izurjenost\",\n        \"alternatives\": [\n          \"dodatek za strokovnost\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"prone\",\n    \"normalized\": \"prone\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"ležeč\"\n      }\n    ]\n  },\n  {\n    \"value\": \"ready\",\n    \"normalized\": \"ready\",\n    \"description\": \"Sometimes you want to get the jump on a foe or wait for a particular circumstance before you act. To do so, you can take the Ready action on your turn, which lets you act using your reaction before the start of your next turn.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"pripraviti se\"\n      }\n    ]\n  },\n  {\n    \"value\": \"religion\",\n    \"normalized\": \"religion\",\n    \"description\": \"Your Intelligence (Religion) check measures your ability to recall lore about deities, rites and prayers, religious hierarchies, holy symbols, and the practices of secret cults.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"vera\",\n        \"alternatives\": [\n          \"religija\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"resistance\",\n    \"normalized\": \"resistance\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"odpornost\"\n      }\n    ]\n  },\n  {\n    \"value\": \"restrained\",\n    \"normalized\": \"restrained\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"pridržan\"\n      }\n    ]\n  },\n  {\n    \"value\": \"save\",\n    \"normalized\": \"save\",\n    \"description\": \"A saving throw — also called a save — represents an attempt to resist a spell, a trap, a poison, a disease, or a similar threat. You don’t normally decide to make a saving throw; you are forced to make one because your character or monster is at risk of harm.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"izogib\"\n      }\n    ]\n  },\n  {\n    \"value\": \"saving throw\",\n    \"normalized\": \"saving throw\",\n    \"description\": \"A saving throw — also called a save — represents an attempt to resist a spell, a trap, a poison, a disease, or a similar threat. You don’t normally decide to make a saving throw; you are forced to make one because your character or monster is at risk of harm.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"izogib\"\n      }\n    ]\n  },\n  {\n    \"value\": \"search\",\n    \"normalized\": \"search\",\n    \"description\": \"When you take the Search action, you devote your attention to finding something. Depending on the nature of your search, the GM might have you make a Wisdom (Perception) check or an Intelligence (Investigation) check.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"iskati\"\n      }\n    ]\n  },\n  {\n    \"value\": \"short rest\",\n    \"normalized\": \"short rest\",\n    \"description\": \"A short rest is a period of downtime, at least 1 hour long, during which a character does nothing more strenuous than eating, drinking, reading, and tending to wounds.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"kratek počitek\",\n        \"alternatives\": [\n          \"premor\",\n          \"kratek odmor\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"shove\",\n    \"normalized\": \"shove\",\n    \"description\": \"Using the Attack action, you can make a special melee attack to shove a creature, either to knock it prone or push it away from you. If you're able to make multiple attacks with the Attack action, this attack replaces one of them.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"odriniti\",\n        \"alternatives\": [\n          \"poriniti\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"skill\",\n    \"normalized\": \"skill\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"veščina\",\n        \"alternatives\": [\n          \"znanje\",\n          \"veda\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"skills\",\n    \"normalized\": \"skills\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"veščine\",\n        \"alternatives\": [\n          \"znanja\",\n          \"vede\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"sleight of hand\",\n    \"normalized\": \"sleight of hand\",\n    \"description\": \"Whenever you attempt an act of legerdemain or manual trickery, such as planting something on someone else or concealing an object on your person, make a Dexterity (Sleight of Hand) check. The GM might also call for a Dexterity (Sleight of Hand) check to determine whether you can lift a coin purse off another person or slip something out of another person's pocket.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"rokovnjaštvo\"\n      }\n    ]\n  },\n  {\n    \"value\": \"stealth\",\n    \"normalized\": \"stealth\",\n    \"description\": \"Make a Dexterity (Stealth) check when you attempt to conceal yourself from enemies, slink past guards, slip away without being noticed, or sneak up on someone without being seen or heard.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"skrivanje\",\n        \"alternatives\": [\n          \"prikrivanje\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"strength\",\n    \"normalized\": \"strength\",\n    \"description\": \"Strength measures bodily power, athletic training, and the extent to which you can exert raw physical force.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"moč\"\n      }\n    ]\n  },\n  {\n    \"value\": \"stunned\",\n    \"normalized\": \"stunned\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"pretresen\"\n      }\n    ]\n  },\n  {\n    \"value\": \"survival\",\n    \"normalized\": \"survival\",\n    \"description\": \"The GM might ask you to make a Wisdom (Survival) check to follow tracks, hunt wild game, guide your group through frozen wastelands, identify signs that owlbears live nearby, predict the weather, or avoid quicksand and other natural hazards.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"preživetje\"\n      }\n    ]\n  },\n  {\n    \"value\": \"tool\",\n    \"normalized\": \"tool\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"orodje\"\n      }\n    ]\n  },\n  {\n    \"value\": \"unconscious\",\n    \"normalized\": \"unconscious\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"nezavesten\",\n        \"alternatives\": [\n          \"nezaveden\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"use an object\",\n    \"normalized\": \"use an object\",\n    \"description\": \"You normally interact with an object while doing something else, such as when you draw a sword as part of an attack. When an object requires your action for its use, you take the Use an Object action. This action is also useful when you want to interact with more than one object on your turn.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"uporabiti predmet\"\n      }\n    ]\n  },\n  {\n    \"value\": \"vulnerability\",\n    \"normalized\": \"vulnerability\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"občutljivost\",\n        \"alternatives\": [\n          \"ranljivost\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"walking speed\",\n    \"normalized\": \"walking speed\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"hitrost peš\",\n        \"alternatives\": [\n          \"hitrost hoje\",\n          \"hitrost po kopnem\"\n        ]\n      }\n    ]\n  },\n  {\n    \"value\": \"weapon\",\n    \"normalized\": \"weapon\",\n    \"description\": \"\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"orožje\"\n      }\n    ]\n  },\n  {\n    \"value\": \"wisdom\",\n    \"normalized\": \"wisdom\",\n    \"description\": \"Wisdom reflects how attuned you are to the world around you and represents perceptiveness and intuition.\",\n    \"translations\": [\n      {\n        \"language\": \"sl\",\n        \"value\": \"modrost\"\n      }\n    ]\n  }\n]","const isSurrogatePair = (codePoint: number) => codePoint > 0xffff;\n\nconst createInclusiveRange = (min: number, max: number) => (x: number) =>\n  min <= x && x <= max;\n\n// compiled from the following sources:\n// - https://en.wikipedia.org/wiki/Combining_character\n// - https://en.wikipedia.org/wiki/Spacing_Modifier_Letters\nconst combiningMarkRanges: [number, number][] = [\n  [0x02b0, 0x02ff],\n  [0x02de, 0x02de],\n  [0x02e0, 0x02e9],\n  [0x02df, 0x02df],\n  [0x02ea, 0x02ff],\n  [0x0300, 0x036f],\n  [0x1ab0, 0x1aff],\n  [0x1dc0, 0x1dff],\n  [0x20d0, 0x20ff],\n  [0xfe20, 0xfe2f],\n  [0x0300, 0x036f],\n  [0x032a, 0x032a],\n  [0x0346, 0x034f],\n  [0x035c, 0x036f],\n  [0x1ab0, 0x1abe],\n  [0x1dc0, 0x1dff],\n  [0x20d0, 0x20ff],\n  [0xfe20, 0xfe2f]\n];\n\nconst allMarks = combiningMarkRanges.map((pair) =>\n  createInclusiveRange(...pair)\n);\n\nconst isAccentedMark = (codePoint: number) =>\n  allMarks.some((isInRange) => isInRange(codePoint));\n\nexport const splitIntoUnicodeCharacters = (text: string = \"\"): string[] => {\n  const characters: string[] = [];\n  let codePointIndex = 0;\n  let codePoint: number;\n  while ((codePoint = text.codePointAt(codePointIndex)!) !== undefined) {\n    if (isSurrogatePair(codePoint)) {\n      characters.push(String.fromCodePoint(codePoint));\n      codePointIndex += 2;\n    } else {\n      characters.push(String.fromCodePoint(codePoint));\n      codePointIndex += 1;\n    }\n    while (\n      (codePoint = text.codePointAt(codePointIndex)!) !== undefined &&\n      isAccentedMark(codePoint)\n    ) {\n      characters[characters.length - 1] += String.fromCodePoint(codePoint);\n      codePointIndex += 1;\n    }\n  }\n  return characters;\n};\n\nexport const normalizeCharacters = (characters: string[]): string[] =>\n  characters.map((char) =>\n    isSurrogatePair(char.codePointAt(0)!)\n      ? char\n      : char.toLocaleLowerCase().normalize(\"NFKD\")[0]\n  );\n\nexport const makeSearchable = (str: string) =>\n  normalizeCharacters(splitIntoUnicodeCharacters(str)).join(\"\");\n","import { Component, For, Show } from \"solid-js\";\nimport dictionary from \"../../../dist/dictionary.json\";\nimport { DictionaryEntry } from \"../../dictionary/interfaces\";\nimport { makeSearchable } from \"../../dictionary/unicode\";\nimport { Language } from \"../../schemas/languages\";\nimport { slugify } from \"../utilities/strings\";\n\ninterface Props {\n  searchTerm: string;\n  language: Language;\n}\n\nconst List: Component<Props> = (props) => {\n  const matches = () => {\n    const needle = makeSearchable(props.searchTerm.trim().toLocaleLowerCase());\n    return needle\n      ? dictionary.filter((entry) => entry.normalized.includes(needle))\n      : dictionary;\n  };\n\n  return (\n    <ul>\n      <For each={matches()}>\n        {(match) => {\n          const t = (\n            match.translations as DictionaryEntry[\"translations\"]\n          ).find((t) => t.language == props.language);\n\n          if (!t) return null;\n\n          const id = slugify(match.value);\n\n          return (\n            <li>\n              <a href={`#${id}`}>\n                <dfn id={id}>{match.value}</dfn>\n              </a>\n              : <strong>{t.value}</strong>\n              <Show when={t.alternatives!?.length > 0}>\n                {\" \"}\n                <em>({t.alternatives!.join(\", \")})</em>\n              </Show>\n              <p>{match.description}</p>\n            </li>\n          );\n        }}\n      </For>\n    </ul>\n  );\n};\n\nexport default List;\n","export const slugify = (source: string) =>\n  encodeURIComponent(source.replace(/\\s/g, \"-\"));\n","import { Component, createSignal } from \"solid-js\";\n\ninterface Props {\n  setSearchTerm: (text: string) => void;\n}\n\nconst Search: Component<Props> = (props) => {\n  return (\n    <input\n      type=\"search\"\n      onInput={(ev) =>\n        props.setSearchTerm((ev.target as HTMLInputElement).value)\n      }\n    />\n  );\n};\n\nexport default Search;\n","import { Component, createSignal } from \"solid-js\";\nimport { Language } from \"../../schemas/languages\";\nimport LanguageSelector from \"./language\";\nimport List from \"./list\";\nimport Search from \"./search\";\n\nconst App: Component = () => {\n  const [searchTerm, setSearchTerm] = createSignal(\"\");\n  const [language, setLanguage] = createSignal<Language>(\"sl\");\n\n  return (\n    <>\n      <h1>Backpacker's Guide to DnD</h1>\n      <LanguageSelector selected={language()} setLanguage={setLanguage} />\n      <Search setSearchTerm={setSearchTerm} />\n      <List searchTerm={searchTerm()} language={language()} />\n    </>\n  );\n};\n\nexport default App;\n","import { render } from \"solid-js/web\";\nimport App from \"./components/app\";\n\nrender(() => <App />, document.getElementById(\"app\")!);\n"],"names":["Object","defineProperty","module","exports","value","default","arr","Array","isArray","iter","Symbol","iterator","from","TypeError","o","minLen","$2c1812367d8ad879$var$_arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","test","obj","parcelRequire","__esModule","len","length","i","arr2","$5f33bd7812edb55e$var$_arrayLikeToArray","key","enumerable","configurable","writable","$d04192d76c552b71$exports","$d04192d76c552b71$var$_arrayWithHoles","$d04192d76c552b71$var$_iterableToArray","$d04192d76c552b71$var$_unsupportedIterableToArray","$d04192d76c552b71$var$_nonIterableRest","$d04192d76c552b71$var$_interopRequireDefault","$79d67f4245e2cd67$exports","$79d67f4245e2cd67$var$_arrayWithoutHoles","$79d67f4245e2cd67$var$_iterableToArray","$79d67f4245e2cd67$var$_unsupportedIterableToArray","$79d67f4245e2cd67$var$_nonIterableSpread","$79d67f4245e2cd67$var$_interopRequireDefault","$c8d6bd51fe763b40$exports","$9QFXR","$a01b50ca4230bde0$exports","target","arguments","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","$a01b50ca4230bde0$var$_defineProperty","$1dbf7b2fc778534e$export$2cb4986bed338027","$1dbf7b2fc778534e$var$setHydrateContext","context","$1dbf7b2fc778534e$var$SuspenseContext","$1dbf7b2fc778534e$export$34b67c27f2ca7498","a","b","$1dbf7b2fc778534e$export$17a675b7c02a7b1d","$1dbf7b2fc778534e$var$signalOptions","equals","$1dbf7b2fc778534e$var$ERROR","$1dbf7b2fc778534e$var$runEffects","$1dbf7b2fc778534e$var$runQueue","$1dbf7b2fc778534e$var$NOTPENDING","$1dbf7b2fc778534e$var$UNOWNED","owned","cleanups","owner","$1dbf7b2fc778534e$var$ref","$parcel$interopDefault","$1dbf7b2fc778534e$export$c1e1e1ecbbe76a5","$1dbf7b2fc778534e$var$setTransPending","$1dbf7b2fc778534e$var$Owner","$1dbf7b2fc778534e$var$Transition","$1dbf7b2fc778534e$var$Scheduler","$1dbf7b2fc778534e$var$ExternalSourceFactory","$1dbf7b2fc778534e$var$Listener","$1dbf7b2fc778534e$var$Pending","$1dbf7b2fc778534e$var$Updates","$1dbf7b2fc778534e$var$Effects","$1dbf7b2fc778534e$var$ExecCount","$1dbf7b2fc778534e$export$882461b6382ed46c","fn","detachedOwner","listener","root","$1dbf7b2fc778534e$var$runUpdates","$1dbf7b2fc778534e$var$cleanNode","value1","options","assign","s","observers","observerSlots","pending","comparator","undefined","$1dbf7b2fc778534e$var$readSignal","bind","running","sources","has","tValue","$1dbf7b2fc778534e$var$writeSignal","$1dbf7b2fc778534e$export$234a23cdc77e6a3d","c","$1dbf7b2fc778534e$var$createComputation","push","$1dbf7b2fc778534e$var$updateComputation","$1dbf7b2fc778534e$export$314dade334ae905d","$1dbf7b2fc778534e$export$c0c6c8b9c16bf6aa","tState","$1dbf7b2fc778534e$export$712ea50be43a7858","result","q","data","$1dbf7b2fc778534e$export$363ebc4b78b8f807","$1dbf7b2fc778534e$export$b36e5eaa3e8c43ab","$1dbf7b2fc778534e$export$7568632d0d33d16d","done","l","Promise","resolve","then","t","Set","effects","promises","disposed","queue","res","$1dbf7b2fc778534e$export$fd42f52fd3ae1109","defaultValue","id","Provider","$1dbf7b2fc778534e$var$createProvider","$1dbf7b2fc778534e$export$bacb5cc5a11aef16","children1","$1dbf7b2fc778534e$var$resolveChildren","runningTransition","this","state","updates","$1dbf7b2fc778534e$var$lookUpstream","sSlot","sourceSlots","node","isComp","TransitionRunning","add","pure","$1dbf7b2fc778534e$var$markDownstream","Error","time","$1dbf7b2fc778534e$var$runComputation","queueMicrotask","nextValue","err","$1dbf7b2fc778534e$var$handleError","updatedAt","init","tOwned","ref6","track","trigger","ordinary","dispose","triggerInTransition","inTransition","x","$1dbf7b2fc778534e$var$runTop","suspense","inFallback","ancestors","top","prev","wait","item","tasks","delete","size","apply","i1","_loop","$1dbf7b2fc778534e$var$scheduleQueue","e","v","$1dbf7b2fc778534e$var$completeUpdates","ignore","pop","index","obs","$1dbf7b2fc778534e$var$reset","fns","$1dbf7b2fc778534e$var$lookup","f","children2","results","props","children","$1dbf7b2fc778534e$var$FALLBACK","$1dbf7b2fc778534e$var$dispose","d","$1dbf7b2fc778534e$var$hydrationEnabled","$1dbf7b2fc778534e$export$60e54eaca7e7fb38","Comp","count","r","$1dbf7b2fc778534e$export$bdf530073099ce9f","fallback","list","mapFn","items","mapped","disposers","indexes","j","newItems","newIndices","newIndicesNext","temp","tempdisposers","tempIndexes","start","end","newEnd","newLen","disposer","mapper","Math","min","Map","get","set","ref8","$1dbf7b2fc778534e$export$4c9116dcf1374231","each","$1dbf7b2fc778534e$export$f6a3d19be20f5819","strictEqual","condition","when","child","$b516e77316b6b0d8$export$b3890eb0ae9dca99","code","element","document","$b516e77316b6b0d8$export$21a5ca8aa77d35ff","firstChild","textContent","$b516e77316b6b0d8$export$ce69bd05624d0c48","html","check","isSVG","createElement","innerHTML","content","$b516e77316b6b0d8$export$ad0f7f87f67e17d6","eventNames","window","addEventListener","$b516e77316b6b0d8$var$eventHandler","$b516e77316b6b0d8$export$9fec4d97f1922e0b","removeAttribute","setAttribute","parent","accessor","marker","initial","$b516e77316b6b0d8$var$insertExpression","current","type","composedPath","registry","querySelectorAll","elem","remove","handler","disabled","cancelBubble","host","Node","parentNode","unwrapArray","childNodes","multi","nodeType","createTextNode","$b516e77316b6b0d8$var$cleanChildren","array","$b516e77316b6b0d8$var$normalizeIncomingArray","$b516e77316b6b0d8$var$appendNodes","bLength","aEnd","bEnd","aStart","bStart","after","nextSibling","map","insertBefore","node1","sequence","node2","replaceChild","$b516e77316b6b0d8$var$reconcileArrays","appendChild","normalized","unwrap","dynamic","replacement","inserted","el","isParent","$bbe91051f2c2c870$export$2e2bcd8739ae039","_el$","$bbe91051f2c2c870$var$_tmpl$","cloneNode","ev","setLanguage","JSON","parse","isSurrogatePair","codePoint","createInclusiveRange","max","allMarks","pair","isAccentedMark","some","isInRange","makeSearchable","str","characters","text","codePointIndex","codePointAt","String","fromCodePoint","splitIntoUnicodeCharacters","char","toLocaleLowerCase","normalize","join","$d4415bc6bb4b67a8$export$2e2bcd8739ae039","$d4415bc6bb4b67a8$var$_tmpl$","needle","searchTerm","trim","dictionary","entry","includes","match","translations","find","language","_el$2","_el$3","_el$4","_el$6","_el$11","encodeURIComponent","replace","$d4415bc6bb4b67a8$var$_tmpl$3","alternatives","_el$7","$d4415bc6bb4b67a8$var$_tmpl$2","_el$10","description","$ea6ad33e82bb40ab$export$2e2bcd8739ae039","$ea6ad33e82bb40ab$var$_tmpl$","$$input","setSearchTerm","$d1f07c439a72aa9d$export$2e2bcd8739ae039","createSignal","$d1f07c439a72aa9d$var$_tmpl$","selected","render","getElementById"],"version":3,"file":"index.22409780.js.map"}